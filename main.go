package main

import (
	"bufio"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"strings"
	"unicode"
)
var ProtoFilePath = `./proto/hamster.proto`

var TemplateLine string = `    %s = "%s",`

var ServiceApiMapTemplate string = `--Generated By go-parse-proto Do not Edit
local config = {
%s
}
return config`

var MatchMapTemplate string = `--Generated By go-parse-proto Do not Edit
local config = {
	Ping = "Pong",
%s
}
return config`

func main() {
	var ServiceNameList = []string{}
	protoFileData,err := ioutil.ReadFile(ProtoFilePath)
	if err == nil {
		sr := strings.NewReader(string(protoFileData))
		reader := bufio.NewReader(sr)
		for {
			line,_,err := reader.ReadLine()
			if err == io.EOF {
				break
			}
			//fmt.Println(string(line),ispre)
			strLine := string(line)
			if strings.HasPrefix(strLine,"message"){
				splitStr := strings.Trim(strLine,"message ")
				serviceName := strings.TrimRight(splitStr," {}")
				ServiceNameList = append(ServiceNameList, serviceName)
			}
		}
	}
	//必须存在request
	//取掉request去找response
	var serviceApiContent string
	for _, s := range (ServiceNameList){
		if strings.Contains(s,"Request") || (strings.Contains(s,"Response") || s == "Ping" || s == "Pong") {
			ret:= Parse(s)
			format := fmt.Sprintf(TemplateLine, ret, s)
			serviceApiContent = serviceApiContent + format + "\n"
		}
	}
	fmt.Println("ServiceApiMap = \n" + serviceApiContent)
	serviceApiMapStr := fmt.Sprintf(ServiceApiMapTemplate, serviceApiContent)
	serviceApiMapDstFile,err :=os.Create("./ServiceApiMap.lua")
	serviceApiMapDstFile.WriteString(serviceApiMapStr)
	serviceApiMapDstFile.Close()

	var matchContent string
	for _, s := range (ServiceNameList){
		if s == "Request" || s == "Response" || s == "Ping" || s == "Pong" {
			continue
		}
		if strings.Contains(s,"Request") {
			replace := strings.ReplaceAll(s,"Request","Response")
			var Contains bool = false
			for _, ss := range (ServiceNameList) {
				if ss == replace {
					Contains = true
					break
				}
			}
			if Contains {
				format := fmt.Sprintf(TemplateLine, s, replace)
				matchContent = matchContent + format + "\n"
			}else{
				fmt.Println("Match not find." + s)
			}
		}
	}

	fmt.Println("MatchMap = \n" + matchContent)
	matchMapOutStr := fmt.Sprintf(MatchMapTemplate, matchContent)
	matchMapDstFile,err :=os.Create("./MatchMap.lua")
	matchMapDstFile.WriteString(matchMapOutStr)
	matchMapDstFile.Close()

	fmt.Println("Parse Successful !")
}

func Parse(str string) string {
	serviceNameRune := []rune(str)
	retServiceName := []rune{}

	for i := 0; i < (len(serviceNameRune) - 1); i++ {
		if i!=0 && unicode.IsUpper(serviceNameRune[i]) && unicode.IsLower(serviceNameRune[i + 1]) {
			retServiceName = append(retServiceName,rune('_'))
		}
		retServiceName = append(retServiceName,unicode.ToUpper(serviceNameRune[i]))
	}
	retServiceName = append(retServiceName,unicode.ToUpper(serviceNameRune[len(serviceNameRune) - 1]))
	return string(retServiceName)
}
